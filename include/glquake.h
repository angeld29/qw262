/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// disable data conversion warnings


#ifdef _WIN32
#ifndef __GNUC__
#pragma warning(disable : 4244)     // MIPS
#pragma warning(disable : 4136)     // X86
#pragma warning(disable : 4051)     // ALPHA
#endif

#include <windows.h>
#endif

#ifndef _WIN32
#ifndef __APPLE__
#include <GL/glx.h>
#endif
#endif

#ifndef __APPLE__
#include <GL/gl.h>
#include <GL/glu.h>
#ifdef __GNUC__
#include <GL/glext.h>
#endif
#else
#include <OpenGL/gl.h>
#include <OpenGL/glu.h>
#include <OpenGL/glext.h>
#define APIENTRY
#endif

#include "gl_mtex.h"
#include "gl_flare.h"

#ifdef USE_HWGAMMA
extern cvar_t	vid_hwgammacontrol;
#endif

void GL_BeginRendering (int *x, int *y, int *width, int *height);
void GL_EndRendering (void);


// Function prototypes for the Texture Object Extension routines
typedef GLboolean (APIENTRY *ARETEXRESFUNCPTR)(GLsizei, const GLuint *,
                    const GLboolean *);
typedef void (APIENTRY *BINDTEXFUNCPTR)(GLenum, GLuint);
typedef void (APIENTRY *DELTEXFUNCPTR)(GLsizei, const GLuint *);
typedef void (APIENTRY *GENTEXFUNCPTR)(GLsizei, GLuint *);
typedef GLboolean (APIENTRY *ISTEXFUNCPTR)(GLuint);
typedef void (APIENTRY *PRIORTEXFUNCPTR)(GLsizei, const GLuint *,
                    const GLclampf *);
typedef void (APIENTRY *TEXSUBIMAGEPTR)(int, int, int, int, int, int, int, int, void *);

extern	BINDTEXFUNCPTR bindTexFunc;
extern	DELTEXFUNCPTR delTexFunc;
extern	TEXSUBIMAGEPTR TexSubImage2DFunc;

extern	int texture_extension_number;

extern	float	gldepthmin, gldepthmax;

#define MAX_GLTEXTURES 1024

void GL_Upload32 (unsigned *data, int width, int height, qboolean mipmap, qboolean alpha);
void GL_Upload8 (byte *data, int width, int height, qboolean mipmap, qboolean alpha, qboolean brighten);
void GL_Upload8_EXT (byte *data, int width, int height, qboolean mipmap, qboolean alpha);
int GL_LoadTexture (char *identifier, int width, int height, byte *data, qboolean mipmap, qboolean alpha, qboolean brighten, int bytesperpixel);

typedef struct
{
	float	x, y, z;
	float	s, t;
	float	r, g, b;
} glvert_t;

extern glvert_t glv;

extern	int glx, gly, glwidth, glheight;

#ifdef _WIN32
extern	PROC glArrayElementEXT;
extern	PROC glColorPointerEXT;
extern	PROC glTexturePointerEXT;
extern	PROC glVertexPointerEXT;
#endif

// r_local.h -- private refresh defs

#define ALIAS_BASE_SIZE_RATIO		(1.0 / 11.0)
					// normalizing factor so player model works out to about
					//  1 pixel per triangle
#define	MAX_LBM_HEIGHT		480

#define TILE_SIZE		128		// size of textures generated by R_GenTiledSurf

#define SKYSHIFT		7
#define	SKYSIZE			(1 << SKYSHIFT)
#define SKYMASK			(SKYSIZE - 1)

#define BACKFACE_EPSILON	0.01


void R_TimeRefresh_f (void);
void R_ReadPointFile_f (void);
texture_t *R_TextureAnimation (texture_t *base);

typedef struct surfcache_s
{
	struct surfcache_s	*next;
	struct surfcache_s 	**owner;		// NULL is an empty chunk of memory
	int					lightadj[MAXLIGHTMAPS]; // checked for strobe flush
	int					dlight;
	int					size;		// including header
	unsigned			width;
	unsigned			height;		// DEBUG only needed for debug
	float				mipscale;
	struct texture_s	*texture;	// checked for animating textures
	byte				data[4];	// width*height elements
} surfcache_t;


typedef struct
{
	pixel_t		*surfdat;	// destination for generated surface
	int			rowbytes;	// destination logical width in bytes
	msurface_t	*surf;		// description for surface to generate
	fixed8_t	lightadj[MAXLIGHTMAPS];
							// adjust for lightmap levels for dynamic lighting
	texture_t	*texture;	// corrected for animating textures
	int			surfmip;	// mipmapped ratio of surface texels / world pixels
	int			surfwidth;	// in mipmapped texels
	int			surfheight;	// in mipmapped texels
} drawsurf_t;


typedef enum {
	pt_static, pt_grav, pt_slowgrav, pt_fire, pt_explode, pt_explode2, pt_blob, pt_blob2
} ptype_t;

//====================================================


extern	entity_t	r_worldentity;
extern	qboolean	r_cache_thrash;		// compatability
extern	vec3_t		modelorg, r_entorigin;
extern	entity_t	*currententity;
extern	int			r_visframecount;	// ??? what difs?
extern	int			r_framecount;
extern	mplane_t	frustum[4];
extern	int		c_brush_polys, c_alias_polys;


//
// view origin
//
extern	vec3_t	vup;
extern	vec3_t	vpn;
extern	vec3_t	vright;
extern	vec3_t	r_origin;

//
// screen size info
//
extern	refdef_t	r_refdef;
extern	mleaf_t		*r_viewleaf, *r_oldviewleaf;
extern	mleaf_t		*r_viewleaf2, *r_oldviewleaf2;	// for watervis hack
extern	texture_t	*r_notexture_mip;
extern	int		d_lightstylevalue[256];	// 8.8 fraction of base light value

extern	qboolean	envmap;
extern	int	currenttexture;
extern	int	cnttextures[2];
extern	int	particletexture;
extern	int	netgraphtexture;	// netgraph texture
extern	int	playertextures;
extern	int	skyboxtextures;
extern	int underwatertexture;
extern	int	skytexturenum;		// index in cl.loadmodel, not gl texture object

extern	cvar_t	r_norefresh;
extern	cvar_t	r_drawentities;
extern	cvar_t	r_drawworld;
extern	cvar_t	r_drawviewmodel;
extern	cvar_t	r_drawflame;
extern	cvar_t	r_speeds;
extern	cvar_t	r_shadows;
extern	cvar_t	r_wateralpha;
extern	cvar_t	r_novis;
extern	cvar_t	r_netgraph;
extern	cvar_t	r_watervishack; // Tonik

extern	cvar_t	gl_clear;
extern	cvar_t	gl_cull;
extern	cvar_t	gl_poly;
extern	cvar_t	gl_texsort;
extern	cvar_t	gl_smoothmodels;
extern	cvar_t	gl_affinemodels;
extern	cvar_t	r_interpolate;  // BorisU, model interpolation
extern	cvar_t	gl_cachemodels; // BorisU
extern	cvar_t	gl_polyblend;
extern	cvar_t	gl_keeptjunctions;
//extern	cvar_t	gl_reporttjunctions;
extern	cvar_t	gl_flashblend;
extern	cvar_t	gl_nocolors;
extern	cvar_t	gl_finish;

// Tonik -->
extern	cvar_t	gl_fb_depthhack;
extern	cvar_t	gl_fb_bmodels;
extern	cvar_t	gl_fb_models;
extern	cvar_t	r_skybox;
extern	cvar_t	r_fullbrightskins;
// <-- Tonik

// fuh -->
extern	cvar_t	gl_caustics;
extern	cvar_t	gl_waterfog;
extern	cvar_t	gl_waterfog_density;
// <- fuh

// BorisU -->
extern	cvar_t	gl_use_24bit_textures;
extern	cvar_t	gl_blend_sprites;
extern	cvar_t	gl_drawskyfirst;
extern	cvar_t	r_farclip;
extern	cvar_t	r_fastblack;
//extern	int		mip_skins[MAX_CLIENTS];
// <-- BorisU

// Tonik -->
extern	cvar_t	gl_colorlights;
extern	cvar_t	gl_lightmode;
extern	int		lightmode;		// set to gl_lightmode on mapchange
// <-- Tonik

extern	cvar_t	gl_loadlitfiles; // fuh

extern	int		gl_lightmap_format;
extern	int		gl_solid_format;
extern	int		gl_alpha_format;

extern	cvar_t	gl_max_size;
extern	cvar_t	gl_playermip;

extern	float	r_world_matrix[16];

extern	const char *gl_vendor;
extern	const char *gl_renderer;
extern	const char *gl_version;
extern	const char *gl_extensions;

void R_TranslatePlayerSkin (int playernum);
void GL_Bind (int texnum);

extern qboolean gl_mtexable;

void GL_DisableMultitexture(void);
void GL_EnableMultitexture(void);

//
// gl_common.c
//
extern byte	color_white[4];
extern byte	color_black[4];

#define GL_TEXTURE_MAX_ANISOTROPY_EXT     0x84FE
#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF

#define GL_MAX_TEXTURE_LOD_BIAS_EXT       0x84FD
#define GL_TEXTURE_FILTER_CONTROL_EXT     0x8500
#define GL_TEXTURE_LOD_BIAS_EXT           0x8501

#define GL_MAX_TEXTURE_LOD_BIAS_EXT       0x84FD
#define GL_TEXTURE_FILTER_CONTROL_EXT     0x8500
#define GL_TEXTURE_LOD_BIAS_EXT           0x8501

#define GL_COMPRESSED_RGB_ARB             0x84ED
#define GL_COMPRESSED_RGBA_ARB            0x84EE
#define GL_TEXTURE_COMPRESSION_HINT_ARB   0x84EF
#define GL_TEXTURE_IMAGE_SIZE_ARB         0x86A0
#define GL_TEXTURE_COMPRESSED_ARB         0x86A1
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3

#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT   0x83F0
#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  0x83F1
#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  0x83F2
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  0x83F3

#define GL_GENERATE_MIPMAP_SGIS           0x8191
#define GL_GENERATE_MIPMAP_HINT_SGIS      0x8192

extern float vid_gamma;
extern unsigned char vid_gamma_table[256];

extern float alpha_test_threshold;
extern float alpha_test_normal;

#ifdef _WIN32
#ifndef __GNUC__
typedef void (APIENTRY * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
#endif
#endif

#ifndef __APPLE__
extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC glCompressedTexImage2DARB;
#endif
extern int gl_has_compression;

void GL_Init (void);
void GL_InitExt (void);
void VID_Init8bitPalette();
void VID_SetGamma(float g);
void Check_Gamma (unsigned char *pal);
void GL_SelectTexture (GLenum target);
qboolean GL_CheckExtension (char* ExtName);

extern float gl_max_anisotropy;
extern cvar_t gl_ext_anisotropy_level;
extern cvar_t gl_ext_lod_bias;
extern cvar_t gl_ext_texture_compress;
extern cvar_t gl_ext_automipmap;

//
// gl_warp.c
//
extern unsigned average_sky_color;
void GL_SubdivideSurface (msurface_t *fa);
void EmitBothSkyLayers (msurface_t *fa);
void EmitWaterPolys (msurface_t *fa);
void EmitUnderwaterPolys (msurface_t *fa);
void EmitSkyPolys (msurface_t *fa);
void R_DrawCausticsChain ();
void R_DrawSkyChainZ (msurface_t *s);
void R_DrawSkyChain (msurface_t *s);
void R_AddSkyBoxSurface (msurface_t *fa);
void R_ClearSkyBox (void);
void R_DrawSkyBox (void);
void R_SetSky (const char *name);
void R_LoadSky_f(void);
extern qboolean	r_skyboxloaded;

//
// gl_draw.c
//
extern int crosshair_texture;
extern cvar_t gl_smoothfont;
int GL_LoadPicTexture (char *name, mpic_t *pic, byte *data);
void GL_Set2D (void);
void Draw_AlphaFill (int x, int y, int w, int h, int c, float alpha);
void Draw_AlphaString (int x, int y, char *str, float alpha);
void Draw_AlphaPic (int x, int y, mpic_t *pic, float alpha);

//
// gl_rmain.c
//
qboolean R_CullBox (vec3_t mins, vec3_t maxs);
qboolean R_CullSphere (vec3_t centre, float radius);
void R_RotateForEntity (entity_t *e);
void R_PolyBlend (void);
void R_BrightenScreen (void);

//
// gl_rlight.c
//
void R_MarkLights (dlight_t *light, int bit, mnode_t *node);
void R_AnimateLight (void);
void R_RenderDlight (dlight_t *light);
void R_RenderDlights (void);
int R_LightPoint (vec3_t p);
extern int lightdata_bytes;

//
// gl_refrag.c
//
void R_StoreEfrags (efrag_t **ppefrag);

//
// gl_mesh.c
//
void GL_MakeAliasModelDisplayLists (model_t *m, aliashdr_t *hdr);

//
// gl_rsurf.c
//
extern int	blacktexturenum; // BorisU
extern int	lightmap_bytes; // 1 or 3

void R_DrawBrushModel (entity_t *e);
void R_DrawWorld (void);
void GL_BuildLightmaps (void);

//
// gl_ngraph.c
//
void R_NetGraph (void);

//
// gl_screen.c
//
extern cvar_t gl_triplebuffer;
extern cvar_t gl_screenshot_format;
extern cvar_t gl_screenshot_jpeg_quality;
extern cvar_t gl_screenshot_png_compression;

#define ALLOW_24BIT_SKYBOX		1
#define ALLOW_24BIT_TEXTURES	2
#define ALLOW_24BIT_FB_TEXTURES	4

//
// gl_rpart.c
//

extern cvar_t gl_part_explosions;
extern cvar_t gl_part_trails;
extern cvar_t gl_part_spikes;
extern cvar_t gl_part_gunshots;
extern cvar_t gl_part_blood;
extern cvar_t gl_part_telesplash;
extern cvar_t gl_part_blobs;
extern cvar_t gl_part_lavasplash;
extern cvar_t gl_part_inferno;

//
// gl_image.c
//
typedef struct {
	byte	*data;
	int		width;
	int		height;
	int		format;
	int		size;
	int		mipmaps;
} gl_image_t;

extern gl_image_t image;

int size_dxtc (int width, int height);

// BorisU -->
typedef struct {
	int		topcolor;
	int		bottomcolor;
	int		mip;
	int		fb_skin;
	char	skinname[16];
} skintexinfo_t;

extern skintexinfo_t skinslots[MAX_CLIENTS];

void Skin_SlotsInit();
int Skin_FindSlot(char* name, int topcolor, int bottomcolor);
int Skin_FindFreeSlot();
// <-- BorisU
